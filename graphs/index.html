<!DOCTYPE html>
<meta charset="utf-8">
<script src="https://d3js.org/d3.v3.min.js"></script>
<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
<script src="https://labratrevenge.com/d3-tip/javascripts/d3.tip.v0.6.3.js"></script>
<style>
path { 
    stroke-width: 2;
    fill: none;
    stroke-linejoin: round;
    stroke-linecap: round;
}
circle { 
  stroke-width: 3;
}
.axis path,
.axis line {
  fill: none;
  stroke: grey;
  stroke-width: 4;
  shape-rendering: crispEdges;
}
.legend, .label, .hover-text{
    font-size: 20px;
    background-color: white;
}

svg {
  top: 300px;
}

h1, h2, h3, h4, h5, h6 {
  float: left;
  width: 100%;
}

ul {
  width: 100%;
}

li {
    display: block;
    float: left;
    font-size: 23px;
    margin-right: 20px;
}

div {
  font-size: 20px;
	float: none;
}

.list {
	width: 100%;
  float: left;
}

.graphs {
  float: center;
	margin-top: 10px;
}

body {
  float: left;
}

p {
  font-weight: bold;
	font-size: 23px;
}

a {
  color: inherit;
}
.type {
	color: blue;
	font-weight: bold;
	font-size: 60px;
}
.d3-tip {
  line-height: 1;
  font-weight: bold;
  padding: 12px;
  background: rgba(0, 0, 0, 0.8);
  color: #fff;
  border-radius: 2px;
}

/* Creates a small triangle extender for the tooltip */
.d3-tip:after {
  box-sizing: border-box;
  display: inline;
  font-size: 10px;
  width: 100%;
  line-height: 1;
  color: rgba(0, 0, 0, 0.8);
  content: "\25BC";
  position: absolute;
  text-align: center;
}

/* Style northward tooltips differently */
.d3-tip.n:after {
  margin: -1px 0 0 0;
  top: 100%;
  left: 0;
}
</style>
<script>
function hideIt(d) {
    var l = document.getElementsByClassName(d.textContent);
    for (var i = 0; i < l.length; i++) {
      if(l[i].style.display=='none'){
        l[i].style.display='block';
        d.style.color='blue';
      } else {
        l[i].style.display='none';
        d.style.color='grey';
      }
    }

}

function checkbox_clicked(checkboxElem) {
  if (checkboxElem.checked) {
    document.getElementById(checkboxElem.parentNode.attributes["name"].nodeValue).style.display='none';
    checkboxElem.parentNode.style.color='grey';    
  } else {
    document.getElementById(checkboxElem.parentNode.attributes["name"].nodeValue).style.display='block';
    checkboxElem.parentNode.style.color='black';    
  }
}
</script>
<div>
<h1><center> Tools </center></h1>
<p id="p1"> zearch: <span style='color:black; font-weight: normal'> Our tool for regular expression searching on grammar-compressed text. Available at <a href="https://github.com/pevalme/zearch"> GitHub </a></span></p>
<p id="p2"> grep: <span style='color:black; font-weight: normal'> <a href="http://ftp.gnu.org/gnu/grep/"> Version 3.1</a>. Counting matching lines with -c option</span></p>
<p id="p3"> ripgrep: <span style='color:black; font-weight: normal'> <a href="https://github.com/BurntSushi/ripgrep/releases">Version 0.10.0</a>. Counting matching lines with -c option</span></p>
<p id="p4"> hyperscan: <span style='color:black; font-weight: normal'> <a href="https://tracker.debian.org/pkg/hyperscan">Version 5.0.0-3</a>. Counting matching lines using a modified version of simplegrep, available at <a href="https://github.com/pevalme/zearch"> GitHub </a> </span></p>
<p id="p5"> lz4|hyperscan: <span style='color:black; font-weight: normal'> Decompress the file with lz4 and count matching lines with hyperscan</span></p>
<p id="p6"> zstd|hyperscan: <span style='color:black; font-weight: normal'> Decompress the file with zstd and count matching lines with hyperscan</span></p>
<p id="p7"> lz4|grep: <span style='color:black; font-weight: normal'> Decompress the file with lz4 and count matching lines with grep</span></p>
<p id="p8"> zstd|grep: <span style='color:black; font-weight: normal'> Decompress the file with zstd and count matching lines with grep</span></p>
<p id="p9"> lz4|ripgrep: <span style='color:black; font-weight: normal'> Decompress the file with lz4 and count matching lines with ripgrep</span></p>
<p id="p10"> zstd|ripgrep: <span style='color:black; font-weight: normal'> Decompress the file with zstd and count matching lines with ripgrep</span></p>
<p id="p11"> repair: <span style='color:black; font-weight: normal'> Grammar based compressor implementin the Recursive Pairing algorithm. Can be downloaded from <a href="https://storage.googleapis.com/google-code-archive-downloads/v2/code.google.com/re-pair/repair110811.tar.gz"> this link </a></span></p>
<p id="p12"> lz4: <span style='color:black; font-weight: normal'> <a href="https://github.com/lz4/lz4">Version 1.8.3</a>. Used with maximum compression level enabled (-9)</span></p>
<p id="p13"> zstd: <span style='color:black; font-weight: normal'> <a href="https://github.com/facebook/zstd">Version 1.3.6</a>. Used with maximum compression level enabled (--ultra -22)</span></p>
<p id="p14"> gzip: <span style='color:black; font-weight: normal'> <a href="http://ftp.gnu.org/gnu/gzip/">Version 1.9</a>. Used with maximum compression level enabled (-9)</span></p>
<br>
<h1><center> Overview </center></h1>
<div class="description">
The running time shown for each regular expression is the <a href="https://en.wikipedia.org/wiki/Confidence_interval">confidence interval</a> computed over 30 runs, measured after a "warming up" run. When the confidence intervals of two experiments do not overlap then we have enough statistical evidence to claim that one tool outperforms the other on the given experiment.
If an execution takes more than 10 times the time required by zearch it is considered a timeout.
</div>
<br>
<hr>
<center><h1 class="type" onclick="hideIt(this)">Subtitles</h1></center>
<div class="list Subtitles">
<h2><center> Regular Expressions </center></h2>
<ul>
<li>r1: ".",</li>
<li>r2: "wosel",</li>
<li>r3: "but where are you",</li>
<li>r4: "have",</li>
<li>r5: "I love you",</li>
<li>r6: "a",</li>
<li>r7: "\.",</li>
<li>r8: "I .* you",</li>
<li>r9: "[a-z]{4}",</li>
<li>r10: "[0-9]{9}",</li>
<li>r11: " (19|20)[0-9]{2} ",</li>
<li>r12: " [a-z]{2} ",</li>
<li>r13: " [0-9]5[0-9]0[0-9]4[0-9]5[0-9] ",</li>
</ul>
</div>
<script>
	var colors20 = d3.scale.category20();
	var color = d3.scale.ordinal()
		.domain(["zearch","grep","ripgrep","hyperscan","zhs_lz4_p","zhs_zstd_p","zgrep_lz4_p","zgrep_zstd_p","zrg_lz4_p","zrg_zstd_p","repair","lz4", "zstd","gzip"])
		.range(["#4363d8","#ffd000","#800000","#808000","#e6194B","#fabebe","#f032e6","#e6beff","#3cb44b","#aaffc3","#4363d8","#f032e6","#42d4f4","#800000"]);
document.getElementById("p1").style.color = color("zearch");
document.getElementById("p2").style.color = color("grep");
document.getElementById("p3").style.color = color("ripgrep");
document.getElementById("p4").style.color = color("hyperscan");
document.getElementById("p5").style.color = color("zhs_lz4_p");
document.getElementById("p6").style.color = color("zhs_zstd_p");
document.getElementById("p7").style.color = color("zgrep_lz4_p");
document.getElementById("p8").style.color = color("zgrep_zstd_p");
document.getElementById("p9").style.color = color("zrg_lz4_p");
document.getElementById("p10").style.color = color("zrg_zstd_p");
document.getElementById("p11").style.color = color("repair");
document.getElementById("p12").style.color = color("lz4");
document.getElementById("p13").style.color = color("zstd");
document.getElementById("p14").style.color = color("gzip");
</script>
<div class="graphs Subtitles">
<h2><center> Graphs </center></h2>
<script>
// Set the color scale

</script>
<svg id="svg1KBSubtitles" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg1KBSubtitles"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 1KB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("1KBSubtitles.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg1KBSubtitles_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg1KBSubtitles_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 1KB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("1KBSubtitles_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info1KBSubtitles_cactus
var info1KBSubtitles_cactus = svg.selectAll(".info1KBSubtitles_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info1KBSubtitles_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info1KBSubtitles_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects1KBSubtitles_cactus");

mouseG.append("path")
  .attr("class", "mouse-line1KBSubtitles_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line1KBSubtitles_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line1KBSubtitles_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info1KBSubtitles_cactus").style("opacity", "0")
    d3.select(".mouse-line1KBSubtitles_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line1KBSubtitles_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line1KBSubtitles_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info1KBSubtitles_cactus").style("opacity", "1")
    d3.select(".mouse-line1KBSubtitles_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line1KBSubtitles_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line1KBSubtitles_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line1KBSubtitles_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line1KBSubtitles_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info1KBSubtitles_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info1KBSubtitles_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg10KBSubtitles" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg10KBSubtitles"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 10KB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("10KBSubtitles.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg10KBSubtitles_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg10KBSubtitles_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 10KB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("10KBSubtitles_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info10KBSubtitles_cactus
var info10KBSubtitles_cactus = svg.selectAll(".info10KBSubtitles_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info10KBSubtitles_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info10KBSubtitles_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects10KBSubtitles_cactus");

mouseG.append("path")
  .attr("class", "mouse-line10KBSubtitles_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line10KBSubtitles_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line10KBSubtitles_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info10KBSubtitles_cactus").style("opacity", "0")
    d3.select(".mouse-line10KBSubtitles_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line10KBSubtitles_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line10KBSubtitles_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info10KBSubtitles_cactus").style("opacity", "1")
    d3.select(".mouse-line10KBSubtitles_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line10KBSubtitles_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line10KBSubtitles_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line10KBSubtitles_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line10KBSubtitles_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info10KBSubtitles_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info10KBSubtitles_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg25KBSubtitles" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg25KBSubtitles"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 25KB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("25KBSubtitles.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg25KBSubtitles_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg25KBSubtitles_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 25KB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("25KBSubtitles_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info25KBSubtitles_cactus
var info25KBSubtitles_cactus = svg.selectAll(".info25KBSubtitles_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info25KBSubtitles_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info25KBSubtitles_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects25KBSubtitles_cactus");

mouseG.append("path")
  .attr("class", "mouse-line25KBSubtitles_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line25KBSubtitles_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line25KBSubtitles_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info25KBSubtitles_cactus").style("opacity", "0")
    d3.select(".mouse-line25KBSubtitles_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line25KBSubtitles_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line25KBSubtitles_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info25KBSubtitles_cactus").style("opacity", "1")
    d3.select(".mouse-line25KBSubtitles_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line25KBSubtitles_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line25KBSubtitles_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line25KBSubtitles_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line25KBSubtitles_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info25KBSubtitles_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info25KBSubtitles_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg50KBSubtitles" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg50KBSubtitles"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 50KB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("50KBSubtitles.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg50KBSubtitles_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg50KBSubtitles_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 50KB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("50KBSubtitles_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info50KBSubtitles_cactus
var info50KBSubtitles_cactus = svg.selectAll(".info50KBSubtitles_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info50KBSubtitles_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info50KBSubtitles_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects50KBSubtitles_cactus");

mouseG.append("path")
  .attr("class", "mouse-line50KBSubtitles_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line50KBSubtitles_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line50KBSubtitles_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info50KBSubtitles_cactus").style("opacity", "0")
    d3.select(".mouse-line50KBSubtitles_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line50KBSubtitles_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line50KBSubtitles_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info50KBSubtitles_cactus").style("opacity", "1")
    d3.select(".mouse-line50KBSubtitles_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line50KBSubtitles_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line50KBSubtitles_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line50KBSubtitles_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line50KBSubtitles_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info50KBSubtitles_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info50KBSubtitles_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg75KBSubtitles" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg75KBSubtitles"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 75KB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("75KBSubtitles.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg75KBSubtitles_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg75KBSubtitles_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 75KB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("75KBSubtitles_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info75KBSubtitles_cactus
var info75KBSubtitles_cactus = svg.selectAll(".info75KBSubtitles_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info75KBSubtitles_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info75KBSubtitles_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects75KBSubtitles_cactus");

mouseG.append("path")
  .attr("class", "mouse-line75KBSubtitles_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line75KBSubtitles_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line75KBSubtitles_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info75KBSubtitles_cactus").style("opacity", "0")
    d3.select(".mouse-line75KBSubtitles_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line75KBSubtitles_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line75KBSubtitles_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info75KBSubtitles_cactus").style("opacity", "1")
    d3.select(".mouse-line75KBSubtitles_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line75KBSubtitles_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line75KBSubtitles_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line75KBSubtitles_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line75KBSubtitles_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info75KBSubtitles_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info75KBSubtitles_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg100KBSubtitles" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100KBSubtitles"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 100KB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("100KBSubtitles.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg100KBSubtitles_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg100KBSubtitles_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 100KB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("100KBSubtitles_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info100KBSubtitles_cactus
var info100KBSubtitles_cactus = svg.selectAll(".info100KBSubtitles_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info100KBSubtitles_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info100KBSubtitles_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects100KBSubtitles_cactus");

mouseG.append("path")
  .attr("class", "mouse-line100KBSubtitles_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line100KBSubtitles_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line100KBSubtitles_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info100KBSubtitles_cactus").style("opacity", "0")
    d3.select(".mouse-line100KBSubtitles_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100KBSubtitles_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100KBSubtitles_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info100KBSubtitles_cactus").style("opacity", "1")
    d3.select(".mouse-line100KBSubtitles_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100KBSubtitles_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100KBSubtitles_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line100KBSubtitles_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line100KBSubtitles_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info100KBSubtitles_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info100KBSubtitles_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg1MBSubtitles" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg1MBSubtitles"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 1MB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("1MBSubtitles.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg1MBSubtitles_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg1MBSubtitles_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 1MB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("1MBSubtitles_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info1MBSubtitles_cactus
var info1MBSubtitles_cactus = svg.selectAll(".info1MBSubtitles_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info1MBSubtitles_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info1MBSubtitles_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects1MBSubtitles_cactus");

mouseG.append("path")
  .attr("class", "mouse-line1MBSubtitles_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line1MBSubtitles_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line1MBSubtitles_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info1MBSubtitles_cactus").style("opacity", "0")
    d3.select(".mouse-line1MBSubtitles_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line1MBSubtitles_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line1MBSubtitles_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info1MBSubtitles_cactus").style("opacity", "1")
    d3.select(".mouse-line1MBSubtitles_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line1MBSubtitles_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line1MBSubtitles_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line1MBSubtitles_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line1MBSubtitles_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info1MBSubtitles_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info1MBSubtitles_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg5MBSubtitles" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg5MBSubtitles"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 5MB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("5MBSubtitles.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg5MBSubtitles_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg5MBSubtitles_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 5MB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("5MBSubtitles_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info5MBSubtitles_cactus
var info5MBSubtitles_cactus = svg.selectAll(".info5MBSubtitles_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info5MBSubtitles_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info5MBSubtitles_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects5MBSubtitles_cactus");

mouseG.append("path")
  .attr("class", "mouse-line5MBSubtitles_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line5MBSubtitles_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line5MBSubtitles_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info5MBSubtitles_cactus").style("opacity", "0")
    d3.select(".mouse-line5MBSubtitles_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line5MBSubtitles_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line5MBSubtitles_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info5MBSubtitles_cactus").style("opacity", "1")
    d3.select(".mouse-line5MBSubtitles_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line5MBSubtitles_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line5MBSubtitles_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line5MBSubtitles_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line5MBSubtitles_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info5MBSubtitles_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info5MBSubtitles_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg10MBSubtitles" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg10MBSubtitles"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 10MB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("10MBSubtitles.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg10MBSubtitles_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg10MBSubtitles_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 10MB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("10MBSubtitles_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info10MBSubtitles_cactus
var info10MBSubtitles_cactus = svg.selectAll(".info10MBSubtitles_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info10MBSubtitles_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info10MBSubtitles_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects10MBSubtitles_cactus");

mouseG.append("path")
  .attr("class", "mouse-line10MBSubtitles_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line10MBSubtitles_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line10MBSubtitles_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info10MBSubtitles_cactus").style("opacity", "0")
    d3.select(".mouse-line10MBSubtitles_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line10MBSubtitles_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line10MBSubtitles_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info10MBSubtitles_cactus").style("opacity", "1")
    d3.select(".mouse-line10MBSubtitles_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line10MBSubtitles_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line10MBSubtitles_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line10MBSubtitles_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line10MBSubtitles_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info10MBSubtitles_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info10MBSubtitles_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg25MBSubtitles" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg25MBSubtitles"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 25MB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("25MBSubtitles.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg25MBSubtitles_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg25MBSubtitles_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 25MB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("25MBSubtitles_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info25MBSubtitles_cactus
var info25MBSubtitles_cactus = svg.selectAll(".info25MBSubtitles_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info25MBSubtitles_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info25MBSubtitles_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects25MBSubtitles_cactus");

mouseG.append("path")
  .attr("class", "mouse-line25MBSubtitles_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line25MBSubtitles_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line25MBSubtitles_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info25MBSubtitles_cactus").style("opacity", "0")
    d3.select(".mouse-line25MBSubtitles_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line25MBSubtitles_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line25MBSubtitles_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info25MBSubtitles_cactus").style("opacity", "1")
    d3.select(".mouse-line25MBSubtitles_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line25MBSubtitles_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line25MBSubtitles_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line25MBSubtitles_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line25MBSubtitles_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info25MBSubtitles_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info25MBSubtitles_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg50MBSubtitles" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg50MBSubtitles"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 50MB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("50MBSubtitles.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg50MBSubtitles_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg50MBSubtitles_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 50MB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("50MBSubtitles_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info50MBSubtitles_cactus
var info50MBSubtitles_cactus = svg.selectAll(".info50MBSubtitles_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info50MBSubtitles_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info50MBSubtitles_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects50MBSubtitles_cactus");

mouseG.append("path")
  .attr("class", "mouse-line50MBSubtitles_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line50MBSubtitles_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line50MBSubtitles_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info50MBSubtitles_cactus").style("opacity", "0")
    d3.select(".mouse-line50MBSubtitles_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line50MBSubtitles_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line50MBSubtitles_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info50MBSubtitles_cactus").style("opacity", "1")
    d3.select(".mouse-line50MBSubtitles_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line50MBSubtitles_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line50MBSubtitles_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line50MBSubtitles_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line50MBSubtitles_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info50MBSubtitles_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info50MBSubtitles_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg100MBSubtitles" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100MBSubtitles"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 100MB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("100MBSubtitles.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg100MBSubtitles_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg100MBSubtitles_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 100MB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("100MBSubtitles_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info100MBSubtitles_cactus
var info100MBSubtitles_cactus = svg.selectAll(".info100MBSubtitles_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info100MBSubtitles_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info100MBSubtitles_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects100MBSubtitles_cactus");

mouseG.append("path")
  .attr("class", "mouse-line100MBSubtitles_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line100MBSubtitles_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line100MBSubtitles_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info100MBSubtitles_cactus").style("opacity", "0")
    d3.select(".mouse-line100MBSubtitles_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100MBSubtitles_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100MBSubtitles_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info100MBSubtitles_cactus").style("opacity", "1")
    d3.select(".mouse-line100MBSubtitles_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100MBSubtitles_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100MBSubtitles_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line100MBSubtitles_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line100MBSubtitles_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info100MBSubtitles_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info100MBSubtitles_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg250MBSubtitles" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg250MBSubtitles"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 250MB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("250MBSubtitles.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg250MBSubtitles_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg250MBSubtitles_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 250MB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("250MBSubtitles_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info250MBSubtitles_cactus
var info250MBSubtitles_cactus = svg.selectAll(".info250MBSubtitles_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info250MBSubtitles_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info250MBSubtitles_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects250MBSubtitles_cactus");

mouseG.append("path")
  .attr("class", "mouse-line250MBSubtitles_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line250MBSubtitles_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line250MBSubtitles_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info250MBSubtitles_cactus").style("opacity", "0")
    d3.select(".mouse-line250MBSubtitles_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line250MBSubtitles_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line250MBSubtitles_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info250MBSubtitles_cactus").style("opacity", "1")
    d3.select(".mouse-line250MBSubtitles_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line250MBSubtitles_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line250MBSubtitles_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line250MBSubtitles_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line250MBSubtitles_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info250MBSubtitles_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info250MBSubtitles_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg500MBSubtitles" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg500MBSubtitles"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 500MB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("500MBSubtitles.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg500MBSubtitles_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg500MBSubtitles_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 500MB Subtitles')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("500MBSubtitles_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info500MBSubtitles_cactus
var info500MBSubtitles_cactus = svg.selectAll(".info500MBSubtitles_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info500MBSubtitles_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info500MBSubtitles_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects500MBSubtitles_cactus");

mouseG.append("path")
  .attr("class", "mouse-line500MBSubtitles_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line500MBSubtitles_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line500MBSubtitles_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info500MBSubtitles_cactus").style("opacity", "0")
    d3.select(".mouse-line500MBSubtitles_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line500MBSubtitles_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line500MBSubtitles_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info500MBSubtitles_cactus").style("opacity", "1")
    d3.select(".mouse-line500MBSubtitles_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line500MBSubtitles_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line500MBSubtitles_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line500MBSubtitles_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line500MBSubtitles_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info500MBSubtitles_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info500MBSubtitles_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
</div>
</script>
<center><h1 class="type" onclick="hideIt(this)">Gutenberg</h1></center>
<div class="list Gutenberg">
<h2><center> Regular Expressions </center></h2>
<ul>
<li>r1: ".",</li>
<li>r2: "wosel",</li>
<li>r3: "but where are you",</li>
<li>r4: "have",</li>
<li>r5: "I love you",</li>
<li>r6: "a",</li>
<li>r7: "\.",</li>
<li>r8: "I .* you",</li>
<li>r9: "[a-z]{4}",</li>
<li>r10: "[0-9]{9}",</li>
<li>r11: " (19|20)[0-9]{2} ",</li>
<li>r12: " [a-z]{2} ",</li>
<li>r13: " [0-9]5[0-9]0[0-9]4[0-9]5[0-9] ",</li>
</ul>
</div>
<script>
	var colors20 = d3.scale.category20();
	var color = d3.scale.ordinal()
		.domain(["zearch","grep","ripgrep","hyperscan","zhs_lz4_p","zhs_zstd_p","zgrep_lz4_p","zgrep_zstd_p","zrg_lz4_p","zrg_zstd_p","repair","lz4", "zstd","gzip"])
		.range(["#4363d8","#ffd000","#800000","#808000","#e6194B","#fabebe","#f032e6","#e6beff","#3cb44b","#aaffc3","#4363d8","#f032e6","#42d4f4","#800000"]);
document.getElementById("p1").style.color = color("zearch");
document.getElementById("p2").style.color = color("grep");
document.getElementById("p3").style.color = color("ripgrep");
document.getElementById("p4").style.color = color("hyperscan");
document.getElementById("p5").style.color = color("zhs_lz4_p");
document.getElementById("p6").style.color = color("zhs_zstd_p");
document.getElementById("p7").style.color = color("zgrep_lz4_p");
document.getElementById("p8").style.color = color("zgrep_zstd_p");
document.getElementById("p9").style.color = color("zrg_lz4_p");
document.getElementById("p10").style.color = color("zrg_zstd_p");
document.getElementById("p11").style.color = color("repair");
document.getElementById("p12").style.color = color("lz4");
document.getElementById("p13").style.color = color("zstd");
document.getElementById("p14").style.color = color("gzip");
</script>
<div class="graphs Gutenberg">
<h2><center> Graphs </center></h2>
<script>
// Set the color scale

</script>
<svg id="svg1KBGutenberg" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg1KBGutenberg"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 1KB Gutenberg')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("1KBGutenberg.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg1KBGutenberg_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg1KBGutenberg_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 1KB Gutenberg')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("1KBGutenberg_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info1KBGutenberg_cactus
var info1KBGutenberg_cactus = svg.selectAll(".info1KBGutenberg_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info1KBGutenberg_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info1KBGutenberg_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects1KBGutenberg_cactus");

mouseG.append("path")
  .attr("class", "mouse-line1KBGutenberg_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line1KBGutenberg_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line1KBGutenberg_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info1KBGutenberg_cactus").style("opacity", "0")
    d3.select(".mouse-line1KBGutenberg_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line1KBGutenberg_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line1KBGutenberg_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info1KBGutenberg_cactus").style("opacity", "1")
    d3.select(".mouse-line1KBGutenberg_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line1KBGutenberg_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line1KBGutenberg_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line1KBGutenberg_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line1KBGutenberg_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info1KBGutenberg_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info1KBGutenberg_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg10KBGutenberg" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg10KBGutenberg"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 10KB Gutenberg')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("10KBGutenberg.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg10KBGutenberg_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg10KBGutenberg_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 10KB Gutenberg')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("10KBGutenberg_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info10KBGutenberg_cactus
var info10KBGutenberg_cactus = svg.selectAll(".info10KBGutenberg_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info10KBGutenberg_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info10KBGutenberg_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects10KBGutenberg_cactus");

mouseG.append("path")
  .attr("class", "mouse-line10KBGutenberg_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line10KBGutenberg_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line10KBGutenberg_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info10KBGutenberg_cactus").style("opacity", "0")
    d3.select(".mouse-line10KBGutenberg_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line10KBGutenberg_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line10KBGutenberg_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info10KBGutenberg_cactus").style("opacity", "1")
    d3.select(".mouse-line10KBGutenberg_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line10KBGutenberg_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line10KBGutenberg_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line10KBGutenberg_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line10KBGutenberg_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info10KBGutenberg_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info10KBGutenberg_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg25KBGutenberg" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg25KBGutenberg"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 25KB Gutenberg')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("25KBGutenberg.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg25KBGutenberg_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg25KBGutenberg_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 25KB Gutenberg')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("25KBGutenberg_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info25KBGutenberg_cactus
var info25KBGutenberg_cactus = svg.selectAll(".info25KBGutenberg_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info25KBGutenberg_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info25KBGutenberg_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects25KBGutenberg_cactus");

mouseG.append("path")
  .attr("class", "mouse-line25KBGutenberg_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line25KBGutenberg_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line25KBGutenberg_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info25KBGutenberg_cactus").style("opacity", "0")
    d3.select(".mouse-line25KBGutenberg_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line25KBGutenberg_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line25KBGutenberg_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info25KBGutenberg_cactus").style("opacity", "1")
    d3.select(".mouse-line25KBGutenberg_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line25KBGutenberg_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line25KBGutenberg_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line25KBGutenberg_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line25KBGutenberg_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info25KBGutenberg_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info25KBGutenberg_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg50KBGutenberg" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg50KBGutenberg"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 50KB Gutenberg')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("50KBGutenberg.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg50KBGutenberg_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg50KBGutenberg_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 50KB Gutenberg')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("50KBGutenberg_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info50KBGutenberg_cactus
var info50KBGutenberg_cactus = svg.selectAll(".info50KBGutenberg_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info50KBGutenberg_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info50KBGutenberg_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects50KBGutenberg_cactus");

mouseG.append("path")
  .attr("class", "mouse-line50KBGutenberg_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line50KBGutenberg_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line50KBGutenberg_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info50KBGutenberg_cactus").style("opacity", "0")
    d3.select(".mouse-line50KBGutenberg_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line50KBGutenberg_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line50KBGutenberg_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info50KBGutenberg_cactus").style("opacity", "1")
    d3.select(".mouse-line50KBGutenberg_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line50KBGutenberg_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line50KBGutenberg_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line50KBGutenberg_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line50KBGutenberg_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info50KBGutenberg_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info50KBGutenberg_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg75KBGutenberg" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg75KBGutenberg"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 75KB Gutenberg')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("75KBGutenberg.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg75KBGutenberg_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg75KBGutenberg_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 75KB Gutenberg')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("75KBGutenberg_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info75KBGutenberg_cactus
var info75KBGutenberg_cactus = svg.selectAll(".info75KBGutenberg_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info75KBGutenberg_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info75KBGutenberg_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects75KBGutenberg_cactus");

mouseG.append("path")
  .attr("class", "mouse-line75KBGutenberg_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line75KBGutenberg_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line75KBGutenberg_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info75KBGutenberg_cactus").style("opacity", "0")
    d3.select(".mouse-line75KBGutenberg_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line75KBGutenberg_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line75KBGutenberg_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info75KBGutenberg_cactus").style("opacity", "1")
    d3.select(".mouse-line75KBGutenberg_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line75KBGutenberg_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line75KBGutenberg_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line75KBGutenberg_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line75KBGutenberg_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info75KBGutenberg_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info75KBGutenberg_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg100KBGutenberg" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100KBGutenberg"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 100KB Gutenberg')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("100KBGutenberg.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg100KBGutenberg_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg100KBGutenberg_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 100KB Gutenberg')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("100KBGutenberg_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info100KBGutenberg_cactus
var info100KBGutenberg_cactus = svg.selectAll(".info100KBGutenberg_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info100KBGutenberg_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info100KBGutenberg_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects100KBGutenberg_cactus");

mouseG.append("path")
  .attr("class", "mouse-line100KBGutenberg_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line100KBGutenberg_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line100KBGutenberg_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info100KBGutenberg_cactus").style("opacity", "0")
    d3.select(".mouse-line100KBGutenberg_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100KBGutenberg_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100KBGutenberg_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info100KBGutenberg_cactus").style("opacity", "1")
    d3.select(".mouse-line100KBGutenberg_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100KBGutenberg_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100KBGutenberg_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line100KBGutenberg_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line100KBGutenberg_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info100KBGutenberg_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info100KBGutenberg_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg1MBGutenberg" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg1MBGutenberg"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 1MB Gutenberg')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("1MBGutenberg.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg1MBGutenberg_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg1MBGutenberg_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 1MB Gutenberg')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("1MBGutenberg_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info1MBGutenberg_cactus
var info1MBGutenberg_cactus = svg.selectAll(".info1MBGutenberg_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info1MBGutenberg_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info1MBGutenberg_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects1MBGutenberg_cactus");

mouseG.append("path")
  .attr("class", "mouse-line1MBGutenberg_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line1MBGutenberg_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line1MBGutenberg_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info1MBGutenberg_cactus").style("opacity", "0")
    d3.select(".mouse-line1MBGutenberg_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line1MBGutenberg_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line1MBGutenberg_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info1MBGutenberg_cactus").style("opacity", "1")
    d3.select(".mouse-line1MBGutenberg_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line1MBGutenberg_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line1MBGutenberg_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line1MBGutenberg_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line1MBGutenberg_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info1MBGutenberg_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info1MBGutenberg_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg5MBGutenberg" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg5MBGutenberg"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 5MB Gutenberg')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("5MBGutenberg.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg5MBGutenberg_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg5MBGutenberg_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 5MB Gutenberg')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("5MBGutenberg_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info5MBGutenberg_cactus
var info5MBGutenberg_cactus = svg.selectAll(".info5MBGutenberg_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info5MBGutenberg_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info5MBGutenberg_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects5MBGutenberg_cactus");

mouseG.append("path")
  .attr("class", "mouse-line5MBGutenberg_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line5MBGutenberg_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line5MBGutenberg_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info5MBGutenberg_cactus").style("opacity", "0")
    d3.select(".mouse-line5MBGutenberg_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line5MBGutenberg_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line5MBGutenberg_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info5MBGutenberg_cactus").style("opacity", "1")
    d3.select(".mouse-line5MBGutenberg_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line5MBGutenberg_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line5MBGutenberg_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line5MBGutenberg_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line5MBGutenberg_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info5MBGutenberg_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info5MBGutenberg_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg10MBGutenberg" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg10MBGutenberg"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 10MB Gutenberg')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("10MBGutenberg.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg10MBGutenberg_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg10MBGutenberg_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 10MB Gutenberg')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("10MBGutenberg_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info10MBGutenberg_cactus
var info10MBGutenberg_cactus = svg.selectAll(".info10MBGutenberg_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info10MBGutenberg_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info10MBGutenberg_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects10MBGutenberg_cactus");

mouseG.append("path")
  .attr("class", "mouse-line10MBGutenberg_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line10MBGutenberg_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line10MBGutenberg_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info10MBGutenberg_cactus").style("opacity", "0")
    d3.select(".mouse-line10MBGutenberg_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line10MBGutenberg_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line10MBGutenberg_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info10MBGutenberg_cactus").style("opacity", "1")
    d3.select(".mouse-line10MBGutenberg_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line10MBGutenberg_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line10MBGutenberg_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line10MBGutenberg_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line10MBGutenberg_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info10MBGutenberg_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info10MBGutenberg_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg25MBGutenberg" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg25MBGutenberg"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 25MB Gutenberg')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("25MBGutenberg.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg25MBGutenberg_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg25MBGutenberg_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 25MB Gutenberg')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("25MBGutenberg_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info25MBGutenberg_cactus
var info25MBGutenberg_cactus = svg.selectAll(".info25MBGutenberg_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info25MBGutenberg_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info25MBGutenberg_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects25MBGutenberg_cactus");

mouseG.append("path")
  .attr("class", "mouse-line25MBGutenberg_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line25MBGutenberg_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line25MBGutenberg_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info25MBGutenberg_cactus").style("opacity", "0")
    d3.select(".mouse-line25MBGutenberg_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line25MBGutenberg_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line25MBGutenberg_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info25MBGutenberg_cactus").style("opacity", "1")
    d3.select(".mouse-line25MBGutenberg_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line25MBGutenberg_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line25MBGutenberg_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line25MBGutenberg_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line25MBGutenberg_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info25MBGutenberg_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info25MBGutenberg_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg50MBGutenberg" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg50MBGutenberg"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 50MB Gutenberg')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("50MBGutenberg.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg50MBGutenberg_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg50MBGutenberg_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 50MB Gutenberg')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("50MBGutenberg_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info50MBGutenberg_cactus
var info50MBGutenberg_cactus = svg.selectAll(".info50MBGutenberg_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info50MBGutenberg_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info50MBGutenberg_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects50MBGutenberg_cactus");

mouseG.append("path")
  .attr("class", "mouse-line50MBGutenberg_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line50MBGutenberg_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line50MBGutenberg_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info50MBGutenberg_cactus").style("opacity", "0")
    d3.select(".mouse-line50MBGutenberg_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line50MBGutenberg_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line50MBGutenberg_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info50MBGutenberg_cactus").style("opacity", "1")
    d3.select(".mouse-line50MBGutenberg_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line50MBGutenberg_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line50MBGutenberg_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line50MBGutenberg_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line50MBGutenberg_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info50MBGutenberg_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info50MBGutenberg_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg100MBGutenberg" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100MBGutenberg"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 100MB Gutenberg')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("100MBGutenberg.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg100MBGutenberg_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg100MBGutenberg_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 100MB Gutenberg')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("100MBGutenberg_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info100MBGutenberg_cactus
var info100MBGutenberg_cactus = svg.selectAll(".info100MBGutenberg_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info100MBGutenberg_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info100MBGutenberg_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects100MBGutenberg_cactus");

mouseG.append("path")
  .attr("class", "mouse-line100MBGutenberg_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line100MBGutenberg_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line100MBGutenberg_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info100MBGutenberg_cactus").style("opacity", "0")
    d3.select(".mouse-line100MBGutenberg_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100MBGutenberg_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100MBGutenberg_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info100MBGutenberg_cactus").style("opacity", "1")
    d3.select(".mouse-line100MBGutenberg_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100MBGutenberg_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100MBGutenberg_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line100MBGutenberg_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line100MBGutenberg_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info100MBGutenberg_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info100MBGutenberg_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg250MBGutenberg" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg250MBGutenberg"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 250MB Gutenberg')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("250MBGutenberg.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg250MBGutenberg_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg250MBGutenberg_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 250MB Gutenberg')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("250MBGutenberg_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info250MBGutenberg_cactus
var info250MBGutenberg_cactus = svg.selectAll(".info250MBGutenberg_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info250MBGutenberg_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info250MBGutenberg_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects250MBGutenberg_cactus");

mouseG.append("path")
  .attr("class", "mouse-line250MBGutenberg_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line250MBGutenberg_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line250MBGutenberg_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info250MBGutenberg_cactus").style("opacity", "0")
    d3.select(".mouse-line250MBGutenberg_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line250MBGutenberg_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line250MBGutenberg_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info250MBGutenberg_cactus").style("opacity", "1")
    d3.select(".mouse-line250MBGutenberg_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line250MBGutenberg_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line250MBGutenberg_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line250MBGutenberg_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line250MBGutenberg_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info250MBGutenberg_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info250MBGutenberg_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg500MBGutenberg" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg500MBGutenberg"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 500MB Gutenberg')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("500MBGutenberg.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg500MBGutenberg_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg500MBGutenberg_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 500MB Gutenberg')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("500MBGutenberg_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info500MBGutenberg_cactus
var info500MBGutenberg_cactus = svg.selectAll(".info500MBGutenberg_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info500MBGutenberg_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info500MBGutenberg_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects500MBGutenberg_cactus");

mouseG.append("path")
  .attr("class", "mouse-line500MBGutenberg_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line500MBGutenberg_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line500MBGutenberg_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info500MBGutenberg_cactus").style("opacity", "0")
    d3.select(".mouse-line500MBGutenberg_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line500MBGutenberg_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line500MBGutenberg_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info500MBGutenberg_cactus").style("opacity", "1")
    d3.select(".mouse-line500MBGutenberg_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line500MBGutenberg_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line500MBGutenberg_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line500MBGutenberg_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line500MBGutenberg_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info500MBGutenberg_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info500MBGutenberg_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
</div>
</script>
<center><h1 class="type" onclick="hideIt(this)">CSV</h1></center>
<div class="list CSV">
<h2><center> Regular Expressions </center></h2>
<ul>
<li>r1: ".",</li>
<li>r2: "wosel",</li>
<li>r3: "1993",</li>
<li>r4: "20[0-9]{2}",</li>
<li>r5: ".*5",</li>
<li>r6: "[a-z]{5}",</li>
<li>r7: " [0-9]{9} ",</li>
</ul>
</div>
<script>
	var colors20 = d3.scale.category20();
	var color = d3.scale.ordinal()
		.domain(["zearch","grep","ripgrep","hyperscan","zhs_lz4_p","zhs_zstd_p","zgrep_lz4_p","zgrep_zstd_p","zrg_lz4_p","zrg_zstd_p","repair","lz4", "zstd","gzip"])
		.range(["#4363d8","#ffd000","#800000","#808000","#e6194B","#fabebe","#f032e6","#e6beff","#3cb44b","#aaffc3","#4363d8","#f032e6","#42d4f4","#800000"]);
document.getElementById("p1").style.color = color("zearch");
document.getElementById("p2").style.color = color("grep");
document.getElementById("p3").style.color = color("ripgrep");
document.getElementById("p4").style.color = color("hyperscan");
document.getElementById("p5").style.color = color("zhs_lz4_p");
document.getElementById("p6").style.color = color("zhs_zstd_p");
document.getElementById("p7").style.color = color("zgrep_lz4_p");
document.getElementById("p8").style.color = color("zgrep_zstd_p");
document.getElementById("p9").style.color = color("zrg_lz4_p");
document.getElementById("p10").style.color = color("zrg_zstd_p");
document.getElementById("p11").style.color = color("repair");
document.getElementById("p12").style.color = color("lz4");
document.getElementById("p13").style.color = color("zstd");
document.getElementById("p14").style.color = color("gzip");
</script>
<div class="graphs CSV">
<h2><center> Graphs </center></h2>
<script>
// Set the color scale

</script>
<svg id="svg1KBCSV" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg1KBCSV"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 1KB CSV')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("1KBCSV.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg1KBCSV_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg1KBCSV_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 1KB CSV')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("1KBCSV_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info1KBCSV_cactus
var info1KBCSV_cactus = svg.selectAll(".info1KBCSV_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info1KBCSV_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info1KBCSV_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects1KBCSV_cactus");

mouseG.append("path")
  .attr("class", "mouse-line1KBCSV_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line1KBCSV_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line1KBCSV_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info1KBCSV_cactus").style("opacity", "0")
    d3.select(".mouse-line1KBCSV_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line1KBCSV_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line1KBCSV_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info1KBCSV_cactus").style("opacity", "1")
    d3.select(".mouse-line1KBCSV_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line1KBCSV_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line1KBCSV_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line1KBCSV_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line1KBCSV_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info1KBCSV_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info1KBCSV_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg10KBCSV" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg10KBCSV"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 10KB CSV')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("10KBCSV.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg10KBCSV_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg10KBCSV_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 10KB CSV')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("10KBCSV_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info10KBCSV_cactus
var info10KBCSV_cactus = svg.selectAll(".info10KBCSV_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info10KBCSV_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info10KBCSV_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects10KBCSV_cactus");

mouseG.append("path")
  .attr("class", "mouse-line10KBCSV_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line10KBCSV_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line10KBCSV_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info10KBCSV_cactus").style("opacity", "0")
    d3.select(".mouse-line10KBCSV_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line10KBCSV_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line10KBCSV_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info10KBCSV_cactus").style("opacity", "1")
    d3.select(".mouse-line10KBCSV_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line10KBCSV_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line10KBCSV_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line10KBCSV_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line10KBCSV_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info10KBCSV_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info10KBCSV_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg25KBCSV" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg25KBCSV"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 25KB CSV')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("25KBCSV.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg25KBCSV_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg25KBCSV_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 25KB CSV')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("25KBCSV_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info25KBCSV_cactus
var info25KBCSV_cactus = svg.selectAll(".info25KBCSV_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info25KBCSV_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info25KBCSV_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects25KBCSV_cactus");

mouseG.append("path")
  .attr("class", "mouse-line25KBCSV_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line25KBCSV_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line25KBCSV_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info25KBCSV_cactus").style("opacity", "0")
    d3.select(".mouse-line25KBCSV_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line25KBCSV_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line25KBCSV_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info25KBCSV_cactus").style("opacity", "1")
    d3.select(".mouse-line25KBCSV_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line25KBCSV_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line25KBCSV_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line25KBCSV_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line25KBCSV_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info25KBCSV_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info25KBCSV_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg50KBCSV" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg50KBCSV"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 50KB CSV')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("50KBCSV.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg50KBCSV_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg50KBCSV_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 50KB CSV')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("50KBCSV_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info50KBCSV_cactus
var info50KBCSV_cactus = svg.selectAll(".info50KBCSV_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info50KBCSV_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info50KBCSV_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects50KBCSV_cactus");

mouseG.append("path")
  .attr("class", "mouse-line50KBCSV_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line50KBCSV_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line50KBCSV_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info50KBCSV_cactus").style("opacity", "0")
    d3.select(".mouse-line50KBCSV_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line50KBCSV_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line50KBCSV_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info50KBCSV_cactus").style("opacity", "1")
    d3.select(".mouse-line50KBCSV_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line50KBCSV_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line50KBCSV_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line50KBCSV_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line50KBCSV_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info50KBCSV_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info50KBCSV_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg75KBCSV" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg75KBCSV"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 75KB CSV')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("75KBCSV.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg75KBCSV_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg75KBCSV_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 75KB CSV')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("75KBCSV_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info75KBCSV_cactus
var info75KBCSV_cactus = svg.selectAll(".info75KBCSV_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info75KBCSV_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info75KBCSV_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects75KBCSV_cactus");

mouseG.append("path")
  .attr("class", "mouse-line75KBCSV_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line75KBCSV_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line75KBCSV_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info75KBCSV_cactus").style("opacity", "0")
    d3.select(".mouse-line75KBCSV_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line75KBCSV_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line75KBCSV_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info75KBCSV_cactus").style("opacity", "1")
    d3.select(".mouse-line75KBCSV_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line75KBCSV_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line75KBCSV_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line75KBCSV_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line75KBCSV_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info75KBCSV_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info75KBCSV_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg100KBCSV" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100KBCSV"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 100KB CSV')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("100KBCSV.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg100KBCSV_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg100KBCSV_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 100KB CSV')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("100KBCSV_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info100KBCSV_cactus
var info100KBCSV_cactus = svg.selectAll(".info100KBCSV_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info100KBCSV_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info100KBCSV_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects100KBCSV_cactus");

mouseG.append("path")
  .attr("class", "mouse-line100KBCSV_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line100KBCSV_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line100KBCSV_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info100KBCSV_cactus").style("opacity", "0")
    d3.select(".mouse-line100KBCSV_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100KBCSV_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100KBCSV_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info100KBCSV_cactus").style("opacity", "1")
    d3.select(".mouse-line100KBCSV_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100KBCSV_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100KBCSV_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line100KBCSV_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line100KBCSV_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info100KBCSV_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info100KBCSV_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg1MBCSV" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg1MBCSV"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 1MB CSV')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("1MBCSV.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg1MBCSV_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg1MBCSV_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 1MB CSV')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("1MBCSV_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info1MBCSV_cactus
var info1MBCSV_cactus = svg.selectAll(".info1MBCSV_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info1MBCSV_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info1MBCSV_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects1MBCSV_cactus");

mouseG.append("path")
  .attr("class", "mouse-line1MBCSV_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line1MBCSV_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line1MBCSV_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info1MBCSV_cactus").style("opacity", "0")
    d3.select(".mouse-line1MBCSV_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line1MBCSV_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line1MBCSV_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info1MBCSV_cactus").style("opacity", "1")
    d3.select(".mouse-line1MBCSV_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line1MBCSV_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line1MBCSV_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line1MBCSV_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line1MBCSV_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info1MBCSV_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info1MBCSV_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg5MBCSV" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg5MBCSV"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 5MB CSV')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("5MBCSV.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg5MBCSV_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg5MBCSV_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 5MB CSV')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("5MBCSV_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info5MBCSV_cactus
var info5MBCSV_cactus = svg.selectAll(".info5MBCSV_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info5MBCSV_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info5MBCSV_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects5MBCSV_cactus");

mouseG.append("path")
  .attr("class", "mouse-line5MBCSV_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line5MBCSV_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line5MBCSV_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info5MBCSV_cactus").style("opacity", "0")
    d3.select(".mouse-line5MBCSV_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line5MBCSV_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line5MBCSV_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info5MBCSV_cactus").style("opacity", "1")
    d3.select(".mouse-line5MBCSV_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line5MBCSV_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line5MBCSV_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line5MBCSV_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line5MBCSV_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info5MBCSV_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info5MBCSV_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg10MBCSV" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg10MBCSV"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 10MB CSV')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("10MBCSV.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg10MBCSV_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg10MBCSV_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 10MB CSV')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("10MBCSV_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info10MBCSV_cactus
var info10MBCSV_cactus = svg.selectAll(".info10MBCSV_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info10MBCSV_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info10MBCSV_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects10MBCSV_cactus");

mouseG.append("path")
  .attr("class", "mouse-line10MBCSV_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line10MBCSV_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line10MBCSV_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info10MBCSV_cactus").style("opacity", "0")
    d3.select(".mouse-line10MBCSV_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line10MBCSV_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line10MBCSV_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info10MBCSV_cactus").style("opacity", "1")
    d3.select(".mouse-line10MBCSV_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line10MBCSV_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line10MBCSV_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line10MBCSV_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line10MBCSV_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info10MBCSV_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info10MBCSV_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg25MBCSV" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg25MBCSV"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 25MB CSV')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("25MBCSV.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg25MBCSV_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg25MBCSV_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 25MB CSV')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("25MBCSV_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info25MBCSV_cactus
var info25MBCSV_cactus = svg.selectAll(".info25MBCSV_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info25MBCSV_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info25MBCSV_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects25MBCSV_cactus");

mouseG.append("path")
  .attr("class", "mouse-line25MBCSV_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line25MBCSV_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line25MBCSV_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info25MBCSV_cactus").style("opacity", "0")
    d3.select(".mouse-line25MBCSV_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line25MBCSV_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line25MBCSV_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info25MBCSV_cactus").style("opacity", "1")
    d3.select(".mouse-line25MBCSV_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line25MBCSV_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line25MBCSV_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line25MBCSV_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line25MBCSV_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info25MBCSV_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info25MBCSV_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg50MBCSV" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg50MBCSV"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 50MB CSV')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("50MBCSV.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg50MBCSV_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg50MBCSV_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 50MB CSV')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("50MBCSV_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info50MBCSV_cactus
var info50MBCSV_cactus = svg.selectAll(".info50MBCSV_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info50MBCSV_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info50MBCSV_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects50MBCSV_cactus");

mouseG.append("path")
  .attr("class", "mouse-line50MBCSV_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line50MBCSV_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line50MBCSV_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info50MBCSV_cactus").style("opacity", "0")
    d3.select(".mouse-line50MBCSV_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line50MBCSV_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line50MBCSV_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info50MBCSV_cactus").style("opacity", "1")
    d3.select(".mouse-line50MBCSV_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line50MBCSV_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line50MBCSV_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line50MBCSV_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line50MBCSV_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info50MBCSV_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info50MBCSV_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg100MBCSV" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100MBCSV"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 100MB CSV')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("100MBCSV.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg100MBCSV_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg100MBCSV_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 100MB CSV')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("100MBCSV_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info100MBCSV_cactus
var info100MBCSV_cactus = svg.selectAll(".info100MBCSV_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info100MBCSV_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info100MBCSV_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects100MBCSV_cactus");

mouseG.append("path")
  .attr("class", "mouse-line100MBCSV_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line100MBCSV_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line100MBCSV_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info100MBCSV_cactus").style("opacity", "0")
    d3.select(".mouse-line100MBCSV_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100MBCSV_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100MBCSV_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info100MBCSV_cactus").style("opacity", "1")
    d3.select(".mouse-line100MBCSV_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100MBCSV_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100MBCSV_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line100MBCSV_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line100MBCSV_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info100MBCSV_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info100MBCSV_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg250MBCSV" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg250MBCSV"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 250MB CSV')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("250MBCSV.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg250MBCSV_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg250MBCSV_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 250MB CSV')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("250MBCSV_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info250MBCSV_cactus
var info250MBCSV_cactus = svg.selectAll(".info250MBCSV_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info250MBCSV_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info250MBCSV_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects250MBCSV_cactus");

mouseG.append("path")
  .attr("class", "mouse-line250MBCSV_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line250MBCSV_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line250MBCSV_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info250MBCSV_cactus").style("opacity", "0")
    d3.select(".mouse-line250MBCSV_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line250MBCSV_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line250MBCSV_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info250MBCSV_cactus").style("opacity", "1")
    d3.select(".mouse-line250MBCSV_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line250MBCSV_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line250MBCSV_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line250MBCSV_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line250MBCSV_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info250MBCSV_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info250MBCSV_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg500MBCSV" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg500MBCSV"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 500MB CSV')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("500MBCSV.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg500MBCSV_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg500MBCSV_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 500MB CSV')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("500MBCSV_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info500MBCSV_cactus
var info500MBCSV_cactus = svg.selectAll(".info500MBCSV_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info500MBCSV_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info500MBCSV_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects500MBCSV_cactus");

mouseG.append("path")
  .attr("class", "mouse-line500MBCSV_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line500MBCSV_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line500MBCSV_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info500MBCSV_cactus").style("opacity", "0")
    d3.select(".mouse-line500MBCSV_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line500MBCSV_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line500MBCSV_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info500MBCSV_cactus").style("opacity", "1")
    d3.select(".mouse-line500MBCSV_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line500MBCSV_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line500MBCSV_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line500MBCSV_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line500MBCSV_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info500MBCSV_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info500MBCSV_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
</div>
</script>
<center><h1 class="type" onclick="hideIt(this)">Logs</h1></center>
<div class="list Logs">
<h2><center> Regular Expressions </center></h2>
<ul>
<li>r1: ".",</li>
<li>r2: "wosel",</li>
<li>r3: "port",</li>
<li>r4: "20[0-9]{2}",</li>
<li>r5: "([0-9]{3}\.){3}[0-9]",</li>
<li>r6: "[0-9]{4}",</li>
<li>r7: "([a-z]+\.)+[a-z]+ - -",</li>
<li>r8: ""GET .*" ([13-9]|2[1-9]|2-[1-9])",</li>
<li>r9: "(([0-9])|([0-2][0-9])|([3][0-1]))/(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)/[0-9]{4}",</li>
<li>r10: "(([0-9])|([0-2][0-9])|([3][0-1]))-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-[0-9]{4}",</li>
</ul>
</div>
<script>
	var colors20 = d3.scale.category20();
	var color = d3.scale.ordinal()
		.domain(["zearch","grep","ripgrep","hyperscan","zhs_lz4_p","zhs_zstd_p","zgrep_lz4_p","zgrep_zstd_p","zrg_lz4_p","zrg_zstd_p","repair","lz4", "zstd","gzip"])
		.range(["#4363d8","#ffd000","#800000","#808000","#e6194B","#fabebe","#f032e6","#e6beff","#3cb44b","#aaffc3","#4363d8","#f032e6","#42d4f4","#800000"]);
document.getElementById("p1").style.color = color("zearch");
document.getElementById("p2").style.color = color("grep");
document.getElementById("p3").style.color = color("ripgrep");
document.getElementById("p4").style.color = color("hyperscan");
document.getElementById("p5").style.color = color("zhs_lz4_p");
document.getElementById("p6").style.color = color("zhs_zstd_p");
document.getElementById("p7").style.color = color("zgrep_lz4_p");
document.getElementById("p8").style.color = color("zgrep_zstd_p");
document.getElementById("p9").style.color = color("zrg_lz4_p");
document.getElementById("p10").style.color = color("zrg_zstd_p");
document.getElementById("p11").style.color = color("repair");
document.getElementById("p12").style.color = color("lz4");
document.getElementById("p13").style.color = color("zstd");
document.getElementById("p14").style.color = color("gzip");
</script>
<div class="graphs Logs">
<h2><center> Graphs </center></h2>
<script>
// Set the color scale

</script>
<svg id="svg1KBLogs" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg1KBLogs"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 1KB Logs')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("1KBLogs.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg1KBLogs_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg1KBLogs_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 1KB Logs')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("1KBLogs_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info1KBLogs_cactus
var info1KBLogs_cactus = svg.selectAll(".info1KBLogs_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info1KBLogs_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info1KBLogs_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects1KBLogs_cactus");

mouseG.append("path")
  .attr("class", "mouse-line1KBLogs_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line1KBLogs_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line1KBLogs_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info1KBLogs_cactus").style("opacity", "0")
    d3.select(".mouse-line1KBLogs_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line1KBLogs_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line1KBLogs_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info1KBLogs_cactus").style("opacity", "1")
    d3.select(".mouse-line1KBLogs_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line1KBLogs_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line1KBLogs_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line1KBLogs_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line1KBLogs_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info1KBLogs_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info1KBLogs_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg10KBLogs" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg10KBLogs"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 10KB Logs')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("10KBLogs.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg10KBLogs_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg10KBLogs_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 10KB Logs')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("10KBLogs_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info10KBLogs_cactus
var info10KBLogs_cactus = svg.selectAll(".info10KBLogs_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info10KBLogs_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info10KBLogs_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects10KBLogs_cactus");

mouseG.append("path")
  .attr("class", "mouse-line10KBLogs_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line10KBLogs_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line10KBLogs_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info10KBLogs_cactus").style("opacity", "0")
    d3.select(".mouse-line10KBLogs_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line10KBLogs_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line10KBLogs_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info10KBLogs_cactus").style("opacity", "1")
    d3.select(".mouse-line10KBLogs_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line10KBLogs_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line10KBLogs_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line10KBLogs_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line10KBLogs_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info10KBLogs_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info10KBLogs_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg25KBLogs" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg25KBLogs"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 25KB Logs')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("25KBLogs.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg25KBLogs_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg25KBLogs_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 25KB Logs')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("25KBLogs_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info25KBLogs_cactus
var info25KBLogs_cactus = svg.selectAll(".info25KBLogs_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info25KBLogs_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info25KBLogs_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects25KBLogs_cactus");

mouseG.append("path")
  .attr("class", "mouse-line25KBLogs_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line25KBLogs_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line25KBLogs_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info25KBLogs_cactus").style("opacity", "0")
    d3.select(".mouse-line25KBLogs_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line25KBLogs_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line25KBLogs_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info25KBLogs_cactus").style("opacity", "1")
    d3.select(".mouse-line25KBLogs_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line25KBLogs_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line25KBLogs_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line25KBLogs_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line25KBLogs_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info25KBLogs_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info25KBLogs_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg50KBLogs" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg50KBLogs"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 50KB Logs')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("50KBLogs.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg50KBLogs_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg50KBLogs_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 50KB Logs')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("50KBLogs_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info50KBLogs_cactus
var info50KBLogs_cactus = svg.selectAll(".info50KBLogs_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info50KBLogs_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info50KBLogs_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects50KBLogs_cactus");

mouseG.append("path")
  .attr("class", "mouse-line50KBLogs_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line50KBLogs_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line50KBLogs_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info50KBLogs_cactus").style("opacity", "0")
    d3.select(".mouse-line50KBLogs_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line50KBLogs_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line50KBLogs_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info50KBLogs_cactus").style("opacity", "1")
    d3.select(".mouse-line50KBLogs_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line50KBLogs_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line50KBLogs_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line50KBLogs_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line50KBLogs_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info50KBLogs_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info50KBLogs_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg75KBLogs" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg75KBLogs"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 75KB Logs')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("75KBLogs.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg75KBLogs_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg75KBLogs_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 75KB Logs')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("75KBLogs_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info75KBLogs_cactus
var info75KBLogs_cactus = svg.selectAll(".info75KBLogs_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info75KBLogs_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info75KBLogs_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects75KBLogs_cactus");

mouseG.append("path")
  .attr("class", "mouse-line75KBLogs_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line75KBLogs_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line75KBLogs_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info75KBLogs_cactus").style("opacity", "0")
    d3.select(".mouse-line75KBLogs_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line75KBLogs_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line75KBLogs_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info75KBLogs_cactus").style("opacity", "1")
    d3.select(".mouse-line75KBLogs_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line75KBLogs_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line75KBLogs_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line75KBLogs_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line75KBLogs_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info75KBLogs_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info75KBLogs_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg100KBLogs" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100KBLogs"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 100KB Logs')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("100KBLogs.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg100KBLogs_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg100KBLogs_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 100KB Logs')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("100KBLogs_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info100KBLogs_cactus
var info100KBLogs_cactus = svg.selectAll(".info100KBLogs_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info100KBLogs_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info100KBLogs_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects100KBLogs_cactus");

mouseG.append("path")
  .attr("class", "mouse-line100KBLogs_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line100KBLogs_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line100KBLogs_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info100KBLogs_cactus").style("opacity", "0")
    d3.select(".mouse-line100KBLogs_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100KBLogs_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100KBLogs_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info100KBLogs_cactus").style("opacity", "1")
    d3.select(".mouse-line100KBLogs_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100KBLogs_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100KBLogs_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line100KBLogs_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line100KBLogs_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info100KBLogs_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info100KBLogs_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg1MBLogs" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg1MBLogs"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 1MB Logs')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("1MBLogs.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg1MBLogs_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg1MBLogs_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 1MB Logs')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("1MBLogs_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info1MBLogs_cactus
var info1MBLogs_cactus = svg.selectAll(".info1MBLogs_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info1MBLogs_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info1MBLogs_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects1MBLogs_cactus");

mouseG.append("path")
  .attr("class", "mouse-line1MBLogs_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line1MBLogs_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line1MBLogs_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info1MBLogs_cactus").style("opacity", "0")
    d3.select(".mouse-line1MBLogs_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line1MBLogs_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line1MBLogs_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info1MBLogs_cactus").style("opacity", "1")
    d3.select(".mouse-line1MBLogs_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line1MBLogs_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line1MBLogs_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line1MBLogs_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line1MBLogs_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info1MBLogs_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info1MBLogs_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg5MBLogs" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg5MBLogs"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 5MB Logs')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("5MBLogs.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg5MBLogs_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg5MBLogs_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 5MB Logs')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("5MBLogs_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info5MBLogs_cactus
var info5MBLogs_cactus = svg.selectAll(".info5MBLogs_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info5MBLogs_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info5MBLogs_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects5MBLogs_cactus");

mouseG.append("path")
  .attr("class", "mouse-line5MBLogs_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line5MBLogs_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line5MBLogs_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info5MBLogs_cactus").style("opacity", "0")
    d3.select(".mouse-line5MBLogs_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line5MBLogs_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line5MBLogs_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info5MBLogs_cactus").style("opacity", "1")
    d3.select(".mouse-line5MBLogs_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line5MBLogs_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line5MBLogs_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line5MBLogs_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line5MBLogs_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info5MBLogs_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info5MBLogs_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg10MBLogs" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg10MBLogs"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 10MB Logs')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("10MBLogs.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg10MBLogs_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg10MBLogs_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 10MB Logs')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("10MBLogs_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info10MBLogs_cactus
var info10MBLogs_cactus = svg.selectAll(".info10MBLogs_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info10MBLogs_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info10MBLogs_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects10MBLogs_cactus");

mouseG.append("path")
  .attr("class", "mouse-line10MBLogs_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line10MBLogs_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line10MBLogs_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info10MBLogs_cactus").style("opacity", "0")
    d3.select(".mouse-line10MBLogs_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line10MBLogs_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line10MBLogs_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info10MBLogs_cactus").style("opacity", "1")
    d3.select(".mouse-line10MBLogs_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line10MBLogs_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line10MBLogs_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line10MBLogs_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line10MBLogs_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info10MBLogs_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info10MBLogs_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg25MBLogs" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg25MBLogs"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 25MB Logs')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("25MBLogs.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg25MBLogs_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg25MBLogs_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 25MB Logs')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("25MBLogs_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info25MBLogs_cactus
var info25MBLogs_cactus = svg.selectAll(".info25MBLogs_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info25MBLogs_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info25MBLogs_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects25MBLogs_cactus");

mouseG.append("path")
  .attr("class", "mouse-line25MBLogs_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line25MBLogs_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line25MBLogs_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info25MBLogs_cactus").style("opacity", "0")
    d3.select(".mouse-line25MBLogs_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line25MBLogs_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line25MBLogs_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info25MBLogs_cactus").style("opacity", "1")
    d3.select(".mouse-line25MBLogs_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line25MBLogs_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line25MBLogs_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line25MBLogs_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line25MBLogs_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info25MBLogs_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info25MBLogs_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg50MBLogs" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg50MBLogs"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 50MB Logs')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("50MBLogs.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg50MBLogs_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg50MBLogs_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 50MB Logs')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("50MBLogs_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info50MBLogs_cactus
var info50MBLogs_cactus = svg.selectAll(".info50MBLogs_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info50MBLogs_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info50MBLogs_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects50MBLogs_cactus");

mouseG.append("path")
  .attr("class", "mouse-line50MBLogs_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line50MBLogs_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line50MBLogs_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info50MBLogs_cactus").style("opacity", "0")
    d3.select(".mouse-line50MBLogs_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line50MBLogs_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line50MBLogs_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info50MBLogs_cactus").style("opacity", "1")
    d3.select(".mouse-line50MBLogs_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line50MBLogs_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line50MBLogs_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line50MBLogs_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line50MBLogs_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info50MBLogs_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info50MBLogs_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg100MBLogs" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100MBLogs"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 100MB Logs')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("100MBLogs.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg100MBLogs_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg100MBLogs_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 100MB Logs')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("100MBLogs_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info100MBLogs_cactus
var info100MBLogs_cactus = svg.selectAll(".info100MBLogs_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info100MBLogs_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info100MBLogs_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects100MBLogs_cactus");

mouseG.append("path")
  .attr("class", "mouse-line100MBLogs_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line100MBLogs_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line100MBLogs_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info100MBLogs_cactus").style("opacity", "0")
    d3.select(".mouse-line100MBLogs_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100MBLogs_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100MBLogs_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info100MBLogs_cactus").style("opacity", "1")
    d3.select(".mouse-line100MBLogs_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100MBLogs_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100MBLogs_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line100MBLogs_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line100MBLogs_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info100MBLogs_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info100MBLogs_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg250MBLogs" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg250MBLogs"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 250MB Logs')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("250MBLogs.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg250MBLogs_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg250MBLogs_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 250MB Logs')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("250MBLogs_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info250MBLogs_cactus
var info250MBLogs_cactus = svg.selectAll(".info250MBLogs_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info250MBLogs_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info250MBLogs_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects250MBLogs_cactus");

mouseG.append("path")
  .attr("class", "mouse-line250MBLogs_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line250MBLogs_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line250MBLogs_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info250MBLogs_cactus").style("opacity", "0")
    d3.select(".mouse-line250MBLogs_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line250MBLogs_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line250MBLogs_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info250MBLogs_cactus").style("opacity", "1")
    d3.select(".mouse-line250MBLogs_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line250MBLogs_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line250MBLogs_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line250MBLogs_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line250MBLogs_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info250MBLogs_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info250MBLogs_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg500MBLogs" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg500MBLogs"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 500MB Logs')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("500MBLogs.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg500MBLogs_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg500MBLogs_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 500MB Logs')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("500MBLogs_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info500MBLogs_cactus
var info500MBLogs_cactus = svg.selectAll(".info500MBLogs_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info500MBLogs_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info500MBLogs_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects500MBLogs_cactus");

mouseG.append("path")
  .attr("class", "mouse-line500MBLogs_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line500MBLogs_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line500MBLogs_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info500MBLogs_cactus").style("opacity", "0")
    d3.select(".mouse-line500MBLogs_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line500MBLogs_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line500MBLogs_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info500MBLogs_cactus").style("opacity", "1")
    d3.select(".mouse-line500MBLogs_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line500MBLogs_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line500MBLogs_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line500MBLogs_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line500MBLogs_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info500MBLogs_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info500MBLogs_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
</div>
</script>
<center><h1 class="type" onclick="hideIt(this)">Qwerty</h1></center>
<div class="list Qwerty">
<h2><center> Regular Expressions </center></h2>
<ul>
<li>r1: ".",</li>
<li>r2: "qwerty",</li>
<li>r3: "qwerti",</li>
<li>r4: "wosel",</li>
<li>r5: "[a-z]{5}",</li>
</ul>
</div>
<script>
	var colors20 = d3.scale.category20();
	var color = d3.scale.ordinal()
		.domain(["zearch","grep","ripgrep","hyperscan","zhs_lz4_p","zhs_zstd_p","zgrep_lz4_p","zgrep_zstd_p","zrg_lz4_p","zrg_zstd_p","repair","lz4", "zstd","gzip"])
		.range(["#4363d8","#ffd000","#800000","#808000","#e6194B","#fabebe","#f032e6","#e6beff","#3cb44b","#aaffc3","#4363d8","#f032e6","#42d4f4","#800000"]);
document.getElementById("p1").style.color = color("zearch");
document.getElementById("p2").style.color = color("grep");
document.getElementById("p3").style.color = color("ripgrep");
document.getElementById("p4").style.color = color("hyperscan");
document.getElementById("p5").style.color = color("zhs_lz4_p");
document.getElementById("p6").style.color = color("zhs_zstd_p");
document.getElementById("p7").style.color = color("zgrep_lz4_p");
document.getElementById("p8").style.color = color("zgrep_zstd_p");
document.getElementById("p9").style.color = color("zrg_lz4_p");
document.getElementById("p10").style.color = color("zrg_zstd_p");
document.getElementById("p11").style.color = color("repair");
document.getElementById("p12").style.color = color("lz4");
document.getElementById("p13").style.color = color("zstd");
document.getElementById("p14").style.color = color("gzip");
</script>
<div class="graphs Qwerty">
<h2><center> Graphs </center></h2>
<script>
// Set the color scale

</script>
<svg id="svg1KBQwerty" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg1KBQwerty"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 1KB Qwerty')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("1KBQwerty.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg1KBQwerty_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg1KBQwerty_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 1KB Qwerty')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("1KBQwerty_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info1KBQwerty_cactus
var info1KBQwerty_cactus = svg.selectAll(".info1KBQwerty_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info1KBQwerty_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info1KBQwerty_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects1KBQwerty_cactus");

mouseG.append("path")
  .attr("class", "mouse-line1KBQwerty_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line1KBQwerty_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line1KBQwerty_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info1KBQwerty_cactus").style("opacity", "0")
    d3.select(".mouse-line1KBQwerty_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line1KBQwerty_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line1KBQwerty_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info1KBQwerty_cactus").style("opacity", "1")
    d3.select(".mouse-line1KBQwerty_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line1KBQwerty_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line1KBQwerty_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line1KBQwerty_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line1KBQwerty_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info1KBQwerty_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info1KBQwerty_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg10KBQwerty" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg10KBQwerty"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 10KB Qwerty')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("10KBQwerty.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg10KBQwerty_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg10KBQwerty_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 10KB Qwerty')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("10KBQwerty_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info10KBQwerty_cactus
var info10KBQwerty_cactus = svg.selectAll(".info10KBQwerty_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info10KBQwerty_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info10KBQwerty_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects10KBQwerty_cactus");

mouseG.append("path")
  .attr("class", "mouse-line10KBQwerty_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line10KBQwerty_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line10KBQwerty_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info10KBQwerty_cactus").style("opacity", "0")
    d3.select(".mouse-line10KBQwerty_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line10KBQwerty_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line10KBQwerty_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info10KBQwerty_cactus").style("opacity", "1")
    d3.select(".mouse-line10KBQwerty_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line10KBQwerty_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line10KBQwerty_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line10KBQwerty_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line10KBQwerty_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info10KBQwerty_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info10KBQwerty_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg25KBQwerty" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg25KBQwerty"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 25KB Qwerty')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("25KBQwerty.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg25KBQwerty_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg25KBQwerty_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 25KB Qwerty')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("25KBQwerty_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info25KBQwerty_cactus
var info25KBQwerty_cactus = svg.selectAll(".info25KBQwerty_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info25KBQwerty_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info25KBQwerty_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects25KBQwerty_cactus");

mouseG.append("path")
  .attr("class", "mouse-line25KBQwerty_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line25KBQwerty_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line25KBQwerty_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info25KBQwerty_cactus").style("opacity", "0")
    d3.select(".mouse-line25KBQwerty_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line25KBQwerty_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line25KBQwerty_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info25KBQwerty_cactus").style("opacity", "1")
    d3.select(".mouse-line25KBQwerty_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line25KBQwerty_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line25KBQwerty_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line25KBQwerty_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line25KBQwerty_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info25KBQwerty_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info25KBQwerty_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg50KBQwerty" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg50KBQwerty"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 50KB Qwerty')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("50KBQwerty.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg50KBQwerty_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg50KBQwerty_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 50KB Qwerty')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("50KBQwerty_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info50KBQwerty_cactus
var info50KBQwerty_cactus = svg.selectAll(".info50KBQwerty_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info50KBQwerty_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info50KBQwerty_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects50KBQwerty_cactus");

mouseG.append("path")
  .attr("class", "mouse-line50KBQwerty_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line50KBQwerty_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line50KBQwerty_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info50KBQwerty_cactus").style("opacity", "0")
    d3.select(".mouse-line50KBQwerty_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line50KBQwerty_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line50KBQwerty_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info50KBQwerty_cactus").style("opacity", "1")
    d3.select(".mouse-line50KBQwerty_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line50KBQwerty_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line50KBQwerty_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line50KBQwerty_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line50KBQwerty_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info50KBQwerty_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info50KBQwerty_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg75KBQwerty" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg75KBQwerty"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 75KB Qwerty')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("75KBQwerty.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg75KBQwerty_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg75KBQwerty_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 75KB Qwerty')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("75KBQwerty_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info75KBQwerty_cactus
var info75KBQwerty_cactus = svg.selectAll(".info75KBQwerty_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info75KBQwerty_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info75KBQwerty_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects75KBQwerty_cactus");

mouseG.append("path")
  .attr("class", "mouse-line75KBQwerty_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line75KBQwerty_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line75KBQwerty_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info75KBQwerty_cactus").style("opacity", "0")
    d3.select(".mouse-line75KBQwerty_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line75KBQwerty_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line75KBQwerty_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info75KBQwerty_cactus").style("opacity", "1")
    d3.select(".mouse-line75KBQwerty_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line75KBQwerty_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line75KBQwerty_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line75KBQwerty_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line75KBQwerty_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info75KBQwerty_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info75KBQwerty_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg100KBQwerty" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100KBQwerty"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 100KB Qwerty')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("100KBQwerty.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg100KBQwerty_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg100KBQwerty_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 100KB Qwerty')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("100KBQwerty_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info100KBQwerty_cactus
var info100KBQwerty_cactus = svg.selectAll(".info100KBQwerty_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info100KBQwerty_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info100KBQwerty_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects100KBQwerty_cactus");

mouseG.append("path")
  .attr("class", "mouse-line100KBQwerty_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line100KBQwerty_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line100KBQwerty_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info100KBQwerty_cactus").style("opacity", "0")
    d3.select(".mouse-line100KBQwerty_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100KBQwerty_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100KBQwerty_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info100KBQwerty_cactus").style("opacity", "1")
    d3.select(".mouse-line100KBQwerty_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100KBQwerty_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100KBQwerty_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line100KBQwerty_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line100KBQwerty_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info100KBQwerty_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info100KBQwerty_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg1MBQwerty" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg1MBQwerty"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 1MB Qwerty')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("1MBQwerty.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg1MBQwerty_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg1MBQwerty_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 1MB Qwerty')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("1MBQwerty_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info1MBQwerty_cactus
var info1MBQwerty_cactus = svg.selectAll(".info1MBQwerty_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info1MBQwerty_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info1MBQwerty_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects1MBQwerty_cactus");

mouseG.append("path")
  .attr("class", "mouse-line1MBQwerty_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line1MBQwerty_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line1MBQwerty_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info1MBQwerty_cactus").style("opacity", "0")
    d3.select(".mouse-line1MBQwerty_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line1MBQwerty_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line1MBQwerty_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info1MBQwerty_cactus").style("opacity", "1")
    d3.select(".mouse-line1MBQwerty_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line1MBQwerty_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line1MBQwerty_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line1MBQwerty_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line1MBQwerty_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info1MBQwerty_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info1MBQwerty_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg5MBQwerty" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg5MBQwerty"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 5MB Qwerty')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("5MBQwerty.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg5MBQwerty_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg5MBQwerty_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 5MB Qwerty')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("5MBQwerty_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info5MBQwerty_cactus
var info5MBQwerty_cactus = svg.selectAll(".info5MBQwerty_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info5MBQwerty_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info5MBQwerty_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects5MBQwerty_cactus");

mouseG.append("path")
  .attr("class", "mouse-line5MBQwerty_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line5MBQwerty_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line5MBQwerty_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info5MBQwerty_cactus").style("opacity", "0")
    d3.select(".mouse-line5MBQwerty_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line5MBQwerty_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line5MBQwerty_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info5MBQwerty_cactus").style("opacity", "1")
    d3.select(".mouse-line5MBQwerty_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line5MBQwerty_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line5MBQwerty_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line5MBQwerty_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line5MBQwerty_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info5MBQwerty_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info5MBQwerty_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg10MBQwerty" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg10MBQwerty"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 10MB Qwerty')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("10MBQwerty.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg10MBQwerty_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg10MBQwerty_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 10MB Qwerty')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("10MBQwerty_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info10MBQwerty_cactus
var info10MBQwerty_cactus = svg.selectAll(".info10MBQwerty_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info10MBQwerty_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info10MBQwerty_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects10MBQwerty_cactus");

mouseG.append("path")
  .attr("class", "mouse-line10MBQwerty_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line10MBQwerty_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line10MBQwerty_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info10MBQwerty_cactus").style("opacity", "0")
    d3.select(".mouse-line10MBQwerty_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line10MBQwerty_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line10MBQwerty_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info10MBQwerty_cactus").style("opacity", "1")
    d3.select(".mouse-line10MBQwerty_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line10MBQwerty_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line10MBQwerty_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line10MBQwerty_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line10MBQwerty_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info10MBQwerty_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info10MBQwerty_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg25MBQwerty" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg25MBQwerty"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 25MB Qwerty')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("25MBQwerty.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg25MBQwerty_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg25MBQwerty_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 25MB Qwerty')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("25MBQwerty_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info25MBQwerty_cactus
var info25MBQwerty_cactus = svg.selectAll(".info25MBQwerty_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info25MBQwerty_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info25MBQwerty_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects25MBQwerty_cactus");

mouseG.append("path")
  .attr("class", "mouse-line25MBQwerty_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line25MBQwerty_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line25MBQwerty_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info25MBQwerty_cactus").style("opacity", "0")
    d3.select(".mouse-line25MBQwerty_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line25MBQwerty_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line25MBQwerty_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info25MBQwerty_cactus").style("opacity", "1")
    d3.select(".mouse-line25MBQwerty_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line25MBQwerty_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line25MBQwerty_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line25MBQwerty_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line25MBQwerty_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info25MBQwerty_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info25MBQwerty_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg50MBQwerty" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg50MBQwerty"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 50MB Qwerty')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("50MBQwerty.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg50MBQwerty_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg50MBQwerty_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 50MB Qwerty')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("50MBQwerty_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info50MBQwerty_cactus
var info50MBQwerty_cactus = svg.selectAll(".info50MBQwerty_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info50MBQwerty_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info50MBQwerty_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects50MBQwerty_cactus");

mouseG.append("path")
  .attr("class", "mouse-line50MBQwerty_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line50MBQwerty_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line50MBQwerty_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info50MBQwerty_cactus").style("opacity", "0")
    d3.select(".mouse-line50MBQwerty_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line50MBQwerty_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line50MBQwerty_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info50MBQwerty_cactus").style("opacity", "1")
    d3.select(".mouse-line50MBQwerty_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line50MBQwerty_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line50MBQwerty_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line50MBQwerty_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line50MBQwerty_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info50MBQwerty_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info50MBQwerty_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg100MBQwerty" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg100MBQwerty"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 100MB Qwerty')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("100MBQwerty.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg100MBQwerty_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg100MBQwerty_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 100MB Qwerty')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("100MBQwerty_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info100MBQwerty_cactus
var info100MBQwerty_cactus = svg.selectAll(".info100MBQwerty_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info100MBQwerty_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info100MBQwerty_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects100MBQwerty_cactus");

mouseG.append("path")
  .attr("class", "mouse-line100MBQwerty_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line100MBQwerty_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line100MBQwerty_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info100MBQwerty_cactus").style("opacity", "0")
    d3.select(".mouse-line100MBQwerty_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100MBQwerty_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line100MBQwerty_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info100MBQwerty_cactus").style("opacity", "1")
    d3.select(".mouse-line100MBQwerty_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100MBQwerty_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line100MBQwerty_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line100MBQwerty_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line100MBQwerty_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info100MBQwerty_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info100MBQwerty_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg250MBQwerty" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg250MBQwerty"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 250MB Qwerty')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("250MBQwerty.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg250MBQwerty_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg250MBQwerty_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 250MB Qwerty')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("250MBQwerty_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info250MBQwerty_cactus
var info250MBQwerty_cactus = svg.selectAll(".info250MBQwerty_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info250MBQwerty_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info250MBQwerty_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects250MBQwerty_cactus");

mouseG.append("path")
  .attr("class", "mouse-line250MBQwerty_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line250MBQwerty_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line250MBQwerty_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info250MBQwerty_cactus").style("opacity", "0")
    d3.select(".mouse-line250MBQwerty_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line250MBQwerty_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line250MBQwerty_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info250MBQwerty_cactus").style("opacity", "1")
    d3.select(".mouse-line250MBQwerty_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line250MBQwerty_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line250MBQwerty_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line250MBQwerty_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line250MBQwerty_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info250MBQwerty_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info250MBQwerty_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
<svg id="svg500MBQwerty" width="1400" height="700"></svg>
<script>
(function() {
// Draw a line chart
var svg = d3.select("#svg500MBQwerty"),
  margin = { top: 100, right: 170, bottom: 100, left: 100 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Search in 500MB Qwerty')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.ordinal().rangeRoundBands([0, width], .1);
var x1 = d3.scale.ordinal();
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";

var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([-10, 0])
  .html(function(d) {
    if (this.parentNode.__data__.name == "lz4" || this.parentNode.__data__.name == "zstd" || this.parentNode.__data__.name == "gzip" || this.parentNode.__data__.name == "repair") {
      return "<strong>No count. Just decompress</strong><br><strong>Time:</strong><span style='color:red'>" + d.worth + "</span>";
    }
    else if(d.matchesg == null && d.matchesr == null && d.matchesgg == null) return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err + "</span>";
    else if (this.parentNode.__data__.name == "GNgrep") return "<strong>Matches:</strong> <span style='color:red'>" + d.matchesn + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
    else return "<strong>Tool:</strong> <span style='color:lightblue'>" + translator[this.parentNode.__data__.name] + "</span><br><strong>Matches:</strong> <span style='color:red'>" + d.matchesg + "</span><br><strong>Time(ms): </strong><span style='color:red'>" + d.worth + "&plusmn" + d.err +"</span>";
  });

svg.call(tip);

var counter = 0;
  // load the data
d3.json("500MBQwerty.json", function(error, data) {
  var xDomain = [];
  // Correct the types
  data.forEach(function(d) {
    xDomain.push(d.Regex);
  });
  console.log(data);

  var tools = color.domain().map(function(name) {
   return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          matchesg: d.MatchesZ,
          matchesr: d.MatchesR,
          matchesgg: d.MatchesGG,
          matchesh: d.MatchesH,
          matchesn: d.MatchesN,
          worth: (name in d ? +d[name].avg : 0),
          err: (name in d ? +d[name].err : 0)
        };
      })
    };
  });
  console.log(tools)
  // Set the X domains
  x.domain(xDomain);
  x1.domain(d3.keys(data[data.length-1]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "MatchesGG" && key !== "gzip" && key !== "repair" && key !== "zstd" && key !== "lz4" && key !== "MatchesH";
  })).rangeRoundBands([0, x.rangeBand()]);
  // Set the Y domain
  y.domain([
    0,
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis);
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the bars
  var state = g.selectAll(".regex")
      .data(tools)
      .enter().append("g")
      .attr("class", "regex")
      .attr("transform", function(d) { return "translate(" + x1(d.name) + ",0)"; });

  state.selectAll("rect")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("rect")
      .attr("width", x1.rangeBand())
      .attr("x", function(d) { return x(d.Regex); })
      .attr("y", function(d) { return y(d.worth); })
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      .attr("height", function(d) { return height - y(d.worth); })
      .style("stroke-width", "0.5")
      .style("stroke", "black")
      .style("fill", function(d){return color(this.parentNode.__data__.name)});

  // Draw the errors
  state.selectAll("line")
      .data(function(d) {
      if (d.name !== "gzip" && d.name !== "repair" && d.name !== "zstd" && d.name !== "lz4")
          return d.values;
        else
          return []; })
      .enter()
      .append("line")
      .attr("x1", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("x2", function(d) { return x(d.Regex) + x1.rangeBand()/2; })
      .attr("y1", function(d) { return y(d.worth-d.err); })
      .attr("y2", function(d) { return y(d.worth+d.err); })
      .style("stroke-width", "4")
      .style("stroke", "black");

  // Draw the lines
  // gzip
  var sum = 0;
  var idx;
  for (idx = 0; idx < tools.length; idx++){
    if (tools[idx].name == "gzip") break;
  }
  var avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("gzip"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // repair
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "repair") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("repair"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // lz4
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "lz4") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("lz4"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  // zstd
  sum = 0;
  idx = 0;
  for (idx = 0; idx <= tools.length; idx++){
    if (tools[idx].name == "zstd") break;
  }
  avg = tools[idx].values[tools[idx].values.length-1].worth;
  g.append("line")
    .style("stroke", color("zstd"))
    .style("stroke-width", "3")
    .style("stroke-dasharray", ("6, 3"))
    .attr("x1", 0)
    .attr("y1", y(avg))
    .attr("x2", width)
    .attr("y2", y(avg));

  var legend = svg.selectAll(".legend")
      .data(color.domain())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right +margin.left) + ", " + (i * 25 + (d == "zstd" || d == "lz4" || d == "gzip" || d == "repair" ? 20 : 0)) + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

});
})();
</script>
<svg id="svg500MBQwerty_cactus" width="1100" height="700"></svg>
<script>
var translator = {};
translator["zearch"] = "zearch";
translator["grep"] = "grep";
translator["ripgrep"] = "ripgrep";
translator["hyperscan"] = "hyperscan";
translator["zhs_lz4_p"] = "lz4|hyperscan";
translator["zhs_zstd_p"] = "zstd|hyperscan";
translator["zgrep_lz4_p"] = "lz4|grep";
translator["zgrep_zstd_p"] = "zstd|grep";
translator["zrg_lz4_p"] = "lz4|ripgrep";
translator["zrg_zstd_p"] = "zstd|ripgrep";
translator["repair"] = "repair";
translator["lz4"] = "lz4";
translator["zstd"] = "zstd";
translator["gzip"] = "gzip";
(function() {
// Draw a line chart
var svg = d3.select("#svg500MBQwerty_cactus"),
  margin = { top: 100, right: 300, bottom: 100, left: 200 },
  width = +svg.attr('width') - margin.left - margin.right,
  height = +svg.attr('height') - margin.top - margin.bottom,
  g = svg.append('g').attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
// Graph title
g.append('text')
  .attr('x', (width / 2))
  .attr('y', 0 - (margin.top / 2))
  .attr('text-anchor', 'middle')
  .style('font-size', '20px')
  .text('Cactus diagram for searching in 500MB Qwerty')
  .style('font-style', "italic");

// Set the X scale
var x = d3.scale.linear().range([0, width]);
// Set the Y scale
var y = d3.scale.linear().range([height, 0]);

var xAxis = d3.svg.axis()
.scale(x)
.orient("bottom");

var yAxis = d3.svg.axis()
.scale(y)
.orient("left");

var line = d3.svg.line()
// .interpolate("basis")
.x(function(d) {
  return x(d.Regex);
})
.y(function(d) {
  return y(d.worth);
});

var counter = 0;
  // load the data
d3.json("500MBQwerty_cactus.json", function(error, data) {
  var tools = color.domain().map(function(name) {
    return {
      name: name,
      values: data.map(function(d) {
        return {
          Regex: d.Regex,
          worth: +d[name]
        };
      })
    };
  });
  console.log(tools)
  // Set the X domain
  x.domain(d3.extent(data, function(d) {
    return d.Regex;
  }));
  // Set the Y domain
  y.domain([
    d3.min(tools, function(c) {
      return d3.min(c.values, function(v) {
        return v.worth;
      });
    }),
    d3.max(tools, function(c) {
      return d3.max(c.values, function(v) {
        return v.worth;
      });
    })
  ]);
  // Set the X axis
  g.append("g")
    .attr("class", "x axis")
    .attr("transform", "translate(0," + height + ")")
    .call(xAxis)
    .append("text")
    .attr("transform", "translate(" + (width + 80) + " ,20)")
    .style("text-anchor", "middle")
    .text("Num regexs");
  // Set the Y axis
  g.append("g")
    .attr("class", "y axis")
    .call(yAxis)
    .append("text")
    .attr("transform", "translate(40,-40)")
    .attr("y", 6)
    .attr("dy", ".71em")
    .style("text-anchor", "end")
    .text("Time (ms)");

  // Draw the lines
  var tool = g.selectAll(".tool")
    .data(tools)
    .enter().append("g")
    .attr("class", "tool");

  tool.append("path")
    .attr("class", "line")
    .attr("d", function(d) {
      return line(d.values);
    })
    .style("stroke", function(d) {
      return color(d.name);
    });
  // Add the circles
  tool.append("g").selectAll("circle")
    .data(function(d){return d.values})
    .enter()
    .append("circle")
    .attr("r", 2)
    .attr("opacity", function(dd){if (isNaN(dd.worth)) return 0; else return 1; })
    .attr("cx", function(dd){return x(dd.Regex)})
    .attr("cy", function(dd){return y(dd.worth)})
    .attr("fill", "none")
    .attr("stroke", function(d){return color(this.parentNode.__data__.name)});

// Add the legend
var legend = svg.selectAll(".legend")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore" && key !== "MatchesH";
  }).slice())
      .enter().append("g")
      .attr("class", "legend")
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + i * 25 + ")"; });

  legend.append("rect")
      .attr("x", width - 18)
      .attr("width", 18)
      .attr("height", 18)
      .style("fill", color);

  legend.append("text")
      .attr("x", width - 24)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .text(function(d) { return translator[d]; });

// Add the info500MBQwerty_cactus
var info500MBQwerty_cactus = svg.selectAll(".info500MBQwerty_cactus")
      .data(d3.keys(data[0]).filter(function(key) {
      return key !== "Regex" && key !== "MatchesG" && key !== "MatchesR" && key !== "Ignore";
  }).slice())
      .enter().append("g")
      .attr("class", "info500MBQwerty_cactus")
      .style("opacity", 0)
      .attr("transform", function(d, i) { return "translate(" + (margin.right + margin.left) + ", " + (270 + i * 25) + ")"; });

  info500MBQwerty_cactus.append("text")
      .attr("x", width)
      .attr("y", 9)
      .attr("dy", ".35em")
      .style("text-anchor", "end")
      .style("font-weight", "bold")
      .text(function(d) { return d+":"; });

// Add the mouse line
var mouseG = g.append("g")
  .attr("class", "mouse-over-effects500MBQwerty_cactus");

mouseG.append("path")
  .attr("class", "mouse-line500MBQwerty_cactus")
  .style("stroke", "black")
  .style("stroke-dasharray", ("5, 5"))
  .style("stroke-width", "2px")
  .style("opacity", "0");

var mousePerLine = mouseG.selectAll('.mouse-per-line500MBQwerty_cactus')
  .data(tools)
  .enter()
  .append("g")
  .attr("class", "mouse-per-line500MBQwerty_cactus");

// Append a rect to catch mouse movements on canvas
mouseG.append('svg:rect')
  .attr('width', width)
  .attr('height', height)
  .attr('fill', 'none')
  .attr('pointer-events', 'all')
  .on('mouseout', function () { // on mouse out hide line, circles and text
    d3.selectAll(".info500MBQwerty_cactus").style("opacity", "0")
    d3.select(".mouse-line500MBQwerty_cactus")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line500MBQwerty_cactus circle")
      .style("opacity", "0");
    d3.selectAll(".mouse-per-line500MBQwerty_cactus text")
      .style("opacity", "0");
  })
  .on('mouseover', function () { // on mouse in show line, circles and text
    d3.selectAll(".info500MBQwerty_cactus").style("opacity", "1")
    d3.select(".mouse-line500MBQwerty_cactus")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line500MBQwerty_cactus circle")
      .style("opacity", "1");
    d3.selectAll(".mouse-per-line500MBQwerty_cactus text")
      .style("opacity", "1");
  })
  .on('mousemove', function () { // mouse moving over canvas
    var mouse = d3.mouse(this);

    d3.selectAll(".mouse-per-line500MBQwerty_cactus")
      .attr("transform", function (d, i) {

        var xPos = mouse[0];
        var err = width / (2 * d.values.length);
        for(idx=0; (x(d.values[idx].Regex) < (xPos - err)) || (x(d.values[idx].Regex) > (xPos + err)); idx++);

        if (!isNaN(d.values[idx].worth)) {
          d3.select(this).select('text')
            .text(y.invert(y(d.values[idx].worth)).toFixed(2));
        } else {
          d3.select(this).select('text').text("");
          d3.select(this).select('circle').style("opacity", 0);
        }

        d3.select(".mouse-line500MBQwerty_cactus")
          .attr("d", function () {
            var data = "M" + x(d.values[idx].Regex) + "," + height;
            data += " " + x(d.values[idx].Regex) + "," + 0;
            return data;
          });

        d3.selectAll(".info500MBQwerty_cactus")[0][i].childNodes[0].innerHTML=translator[d.name]+": "+d.values[idx].worth;
        d3.selectAll(".info500MBQwerty_cactus")[0][i].childNodes[0].style.fill=color(d.name);

        return "translate(" + x(d.values[idx].Regex) + "," + y(d.values[idx].worth) + ")";
      });
  });
});
})();
</script>
</div>
</script>
